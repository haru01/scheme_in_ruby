\chapter{プログラムと評価\hspace{-3mm}}

\section{プログラミング言語とは}

プログラミング言語とはプログラムを書くための言語です。プログラミング言
語の処理系とは、与えられたプログラムを計算するもので、コンパイラと実行
系やインタープリタといったものがあります。本書ではプログラムを逐次
解釈し実行していくインタープリタというものを作って行きます。処理系でプ
ログラムの動作を表現することで、プログラミング言語の定義を行います
\footnote{このような方法を操作的意味論(operetional semantics)で定義され
たプログラミング言語と言います}。

では、そもそもプログラムとは何でしょう。計算するための手順などとも言えそうですが、本文書では概念的なものではなく、実際に簡単なプログラムの例を示しながらそれが動くように少しずつ機能を追加していきます。

\section{はじめてのプログラムの評価}

最初のプログラムとして次のプログラムを考えます。

\begin{lstlisting}
[:+, 1, 2]
\end{lstlisting}

今までのプログラムと全く異なる記述方法に戸惑うことでしょう。当然です。これは著者が勝手に考えた$\mu$SchemeR(名前も勝手に考えました)というプログラミング言語だからです。気にくわない書き方だと思いますが、この文書を読み終わるころには自分の好きな書き方へ直せる力が身についていると思いますので少しお付き合い下さい。

ただ少し想像力を働かせれば、多くの人は1と2を足し合わせるプログラムなのだと想像できるのではないでしょうか。そのとおり、正解です。では、“このプログラムを与えられた時にこの結果を求める処理を考えて下さい”と言われたとき、どう答えるでしょうか。“1と2を足し合わせた結果を求める”もしくは“{\tt :+}が先頭にあった時、続く2つの引数の値を足し合わせる”とも言えるでしょう。

では、次のプログラムの結果を求める処理はどうでしょう。

\begin{lstlisting}
[:+, [:+, 1, 2], 3]
\end{lstlisting}

“まず{\tt [:+, 1, 2]}を計算してその結果と3とを足し合わせる”と言えるでしょう。ここで前回の説明に“計算して”という言葉が加わったことに気づいたでしょうか。すなわち、上2つのプログラムの計算結果を求める処理を考えたとき、その処理は{\tt :+}に続く引数を“計算”した後に足し合わせる必要があるのです。通常、我々はこの計算のことを“評価(evaluation)”と言います。したがって、“{\tt :+}が先頭にあった時、続く2つの引数を評価して、その値を足し合わせる”が求める答えです。

\begin{boxnote}
{\bf コラム: $\mu$SchemeRのシンタックス} \\

今回作成するプログラミング言語$\mu$SchemeRでは、{\tt [:+, 1, 2]}などのように
最初に関数を、その後引数を記述します。また、要素は“{\tt ,}”で区切りそれらを“{\tt [}”と“{\tt ]}”で囲みリストを表します。この形式は、Rubyで配列としてそのまま扱えるため、余計な処理を考えなくて良いという利点があります。また、記号である{\tt +}や変数である{\tt x}や予約後{\tt if}などは、単語のはじめに{\tt :}をつけてそれぞれ{\tt :+}、{\tt :x}、{\tt :if}と記します。この表記法もRubyでそのままシンボルとして扱えるために導入しています。
\end{boxnote}

それでは、このプログラムの結果を求める処理をRubyで記述してみましょう。

{\tt \_eval}\footnote{{\tt eval}としないで{\tt \_eval}としているのは、Rubyの組み込み関数として{\tt eval}が定義されているためです。}は、与えられた式{\tt exp}を評価し、その結果を返します。

式がリストであった場合、最初の要素を関数として、残りを引数として、それぞれを評価してその値を求めます。求めた関数に求めた引数の値を適用(apply)してその結果を{\tt \_eval}の結果とします\footnote{Rubyでは、関数の最後に評価した式の値が関数の返り値になります。関数型言語では{\tt return} {\it 値}と書かずに、このような書き方を一般的にします。本文書では、関数型言語の考え方に近づくようにこの記述を利用していきます。}。一方、リストでない場合、数字であれば即値として扱い数字そのものを返します。例えば{\tt 2}は2を返します。そうでなければ、組み込み関数とみなし、それに関連付けられた(Ruby上での)関数を返します。

\begin{lstlisting}
def _eval(exp)
  if not list?(exp) 
    if immediate_val?(exp)
      exp
    else 
      lookup_primitive_fun(exp)
    end
  else
    fun = _eval(car(exp))
    args = eval_list(cdr(exp))
    apply(fun, args)
  end
end
\end{lstlisting}

\begin{boxnote}
{\bf コラム: プログラムコードと値の区別} \\

“{\tt 2}は2を返します”という文章で数字のフォントが違っていることに気づきましたか? {\tt 2}は(現在考えている$\mu$SchemeR)プログラムの、2は(Ruby上での)数値の2を表します。こう記載することによって、プログラムとその評価された値とを区別します。
\end{boxnote}

以降、上のRubyプログラムで呼ばれている関数を説明していきます。

リストかどうかは配列のインスタンスかどうかで判断しています。

\begin{lstlisting}
def list?(exp)
  Array === exp
end
\end{lstlisting}

組み込み関数は、関数名をキーに、関数本体をその値としたハッシュで保有しま
す。関連付けられている関数はRuby上での関数です。組み込み関数の評価は、
関数名に関連付けられた関数を値として返します。

\begin{lstlisting}
def lookup_primitive_fun(exp)
  $primitive_fun_env[exp]
end

$primitive_fun_env = {
  :+ => [:prim, lambda{|x, y| x + y}],
  :- => [:prim, lambda{|x, y| x - y}],
  :* => [:prim, lambda{|x, y| x * y}], 
}
\end{lstlisting}

{\tt car}はリストの先頭の要素を、{\tt cdr}は先頭の要素以降のリストを取得する関数です。この名前は奇妙ですが、Schemeで使われている名前ですので我慢してください。そのうち慣れます。

\begin{lstlisting}
def car(list)
  list[0]
end

def cdr(list)
  list[1...list.length]
end
\end{lstlisting}

引数を評価する{\tt eval\_list}は、リストの要素それぞれを評価したものをリストにしたものです。

\begin{lstlisting}
def eval_list(exp)
  exp.map{|e| _eval(e)}
end    
\end{lstlisting}

そのままの値を返す即値として数字を定義しています。

\begin{lstlisting}
def immediate_val? exp
  num?(exp) 
end

def num? exp
  Numeric === exp
end
\end{lstlisting}

関数適用は、引数の評価値(Ruby上の値になります)を(Ruby上の)関数へ適用しています。
{\tt fun\_val[*args]}は、{\tt fun\_val}というRuby上の関数を引数を{\tt args}で呼び出します。{\tt *}は、可変長引数に対応しており、{\tt args}が{\tt [1, 2]}の場合{\tt fun\_val[1, 2]}と展開され、{\tt args}が{\tt [1, 2, 3]}の場合{\tt fun\_val[1, 2, 3]}と展開されます。

\begin{lstlisting}
def apply(fun, args)
  apply_primitive_fun(fun, args)
end

def apply_primitive_fun(fun, args)
  fun_val = fun[1]
  fun_val[*args]
end

def primitive_fun? exp
  exp[0] == :prim
end
\end{lstlisting}

実際に、{\tt [:+, 1, 2]}を評価するときの動きを追ってみましょう。与えるプログラムはリストですのでまず先頭の要素{\tt :+}を評価し、$lambda\{|x, y| x + y\}$を値として得ます。これは、二つの引数を足す(Ruby上の)関数です。次に{\tt 1}, {\tt 2}を評価し、それぞれ(Ruby上での)1, 2を得ます。これを(Ruby上で)適用することで、3を得ます。この値はprintなどRuby上のプログラムで表示することができます\footnote{今回作成している$\mu$SchemeR上でも、もちろん表示出来ますが、それは後のお楽しみとします}。

\begin{lstlisting}
puts _eval([:+, 1, 2])
\end{lstlisting}

を実行して3が表示されましたか。おめでとうございます。おそらく、あなたははじめてプログラミング言語のインタープリタを作ったのではないでしょうか。足し算しか出来ないプログラミング言語なので実感は無いかもしれませんが、正真正銘のプログラミング言語の処理系です。

{\tt [:+, [:+, 1, 2], 3]}が評価される流れも自分で追ってみて下さい。{\tt \_eval}が再帰的に呼ばれている点が役立っていることに気づけましたか。

\section{まとめ}

この章では次のことを学びました。

\begin{itemize}
\item 簡単なプログラムの計算方法(また、我々はこの計算を“評価”と呼びました)
\item 関数適用の評価方法、すなわち、関数と引数を評価して、得られた関数の評価値に引数の評価値を関数適用するということ
\item プログラムが評価されると(プログラムの実行結果はRubyという)他の世界の値として得られること
\end{itemize}

普段何気なく書いている{\tt x = y;}というプログラムは、実際は右辺をまず評価してその値を左辺の変数のアドレスに格納する、ということを行っています。漠然とは理解していたと思いますが、実際は本章で学んだ評価という考え方などに基づいてプログラムは実行されています。その内部を少し垣間見ることが出来たのではないでしょうか。
